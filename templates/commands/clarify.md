---
description: 通过提出高度针对性的澄清问题（按组提问，每组最多 5 个），识别当前功能规范中未充分说明的领域，并按照依赖顺序将答案编码回规范中。
handoffs:
  - label: 构建技术计划
    agent: /speckit.plan
    prompt: 为规范创建计划。我正在构建...
scripts:
   sh: scripts/bash/check-prerequisites.sh --json --paths-only
   ps: scripts/powershell/check-prerequisites.ps1 -Json -PathsOnly
---

## 用户输入

```text
$ARGUMENTS
```

在继续之前, 你**必须**考虑用户输入(如果不为空). 用户可以通过以下方式提供参考文档: 
- **文件路径**: 直接列出本地文件路径 (如 `docs/api.md`, `specs/legacy_v1.pdf`).
- **IDE 上下文**: 提及当前打开的文件或选中的代码块.
- **外部链接**: 提供可访问的 URL (如 GitHub Issue 链接、设计文档链接).
- **自然语言描述**: 用户直接在对话中粘贴的文本片段或对特定逻辑的描述.

## 概述

目标: 检测并减少活跃功能规范中的模糊性、缺失决策点或文档间的不一致，并将澄清内容直接记录在规范文件中，确保规范与关联文档（如计划和任务）保持对齐。

注意: 此澄清工作流应在调用 `/speckit.plan` 之前运行(并完成). 如果用户明确表示他们跳过澄清(例如, 探索性原型), 你可以继续, 但必须警告下游返工风险增加.

执行步骤: 

1. 从仓库根目录运行 `{SCRIPT}` **一次**(组合 `--json --paths-only` 模式 / `-Json -PathsOnly`). 解析最小 JSON 负载字段: 
   - `FEATURE_DIR`
   - `FEATURE_SPEC`
   - (可选捕获 `IMPL_PLAN`、`TASKS` 用于未来的链式流程. )
   - 如果 JSON 解析失败, 中止并指示用户重新运行 `/speckit.specify` 或验证功能分支环境.
   - 对于参数中包含单引号的情况(如 "I'm Groot"), 使用转义语法: 例如 'I'\''m Groot'(或优先使用双引号: "I'm Groot").

2. 加载当前规范文件 (`FEATURE_SPEC`) 及其关联文档 (如 `IMPL_PLAN`, `TASKS`, 或用户在参数中提供的**任意多个输入参考文档**). 执行**跨文档多重比对与知识提取**，识别各文档间的冲突、逻辑断层或规范中缺失的补充信息。使用此分类法执行结构化模糊性和覆盖范围扫描. 对于每个类别, 标记状态: 清晰 / 部分 / 缺失. 生成用于优先级排序的内部覆盖范围图(除非不会提问, 否则不输出原始图).

   文档一致性与补充对比 (跨文档比对): 
   - 规范与实现计划 (`IMPL_PLAN`) 的目标对齐情况
   - 规范与任务列表 (`TASKS`) 的需求覆盖完整性
   - **外部输入文档集成**：提取用户提供的多个参考文档中的核心约束、技术细节或业务逻辑，并与当前规范对比
   - 跨文档的术语定义、数据模型和逻辑路径一致性
   - 识别计划、任务或输入文档中引入但规范未定义的隐性需求、假设或约束

   功能范围与行为: 
   - 核心用户目标和成功标准
   - 明确的超出范围声明
   - 用户角色 / 角色区分

   领域与数据模型: 
   - 实体、属性、关系
   - 身份和唯一性规则
   - 生命周期 / 状态转换
   - 数据量 / 规模假设

   交互与 UX 流程: 
   - 关键用户旅程 / 序列
   - 错误 / 空白 / 加载状态
   - 可访问性或本地化说明

   非功能性质量属性: 
   - 性能(延迟、吞吐量目标)
   - 可扩展性(水平 / 垂直、限制)
   - 可靠性和可用性(正常运行时间、恢复期望)
   - 可观察性(日志、指标、追踪信号)
   - 安全性和隐私(身份验证 / 授权、数据保护、威胁假设)
   - 合规性 / 监管约束(如有)

   集成与外部依赖: 
   - 外部服务 / API 和故障模式
   - 数据导入 / 导出格式
   - 协议 / 版本控制假设

   边缘情况与故障处理: 
   - 负面场景
   - 速率限制 / 节流
   - 冲突解决(例如, 并发编辑)

   约束与权衡: 
   - 技术约束(语言、存储、托管)
   - 明确的权衡或被拒绝的替代方案

   术语与一致性: 
   - 规范术语表术语
   - 避免的同义词 / 已弃用术语

   完成信号: 
   - 验收标准可测试性
   - 可衡量的完成定义风格指标

   其他 / 占位符: 
   - TODO 标记 / 未解决的决策
   - 缺少量化的模糊形容词("robust"、"intuitive")

   对于每个处于部分或缺失状态的类别, 添加候选问题机会, 除非: 
   - 澄清不会实质性地改变实施或验证策略
   - 信息更适合推迟到规划阶段(内部记录)

3. (内部)生成候选澄清问题的优先级队列与依赖图. 应用这些约束: 
    - 识别问题间的依赖关系 (例如: 问题 B 只有在问题 A 得到回答后才有意义).
    - 按照依赖顺序和优先级对问题进行排序.
    - 整个会话建议总计不超过 10 个问题, 优先处理最高影响力的未解决类别.
    - 每个问题必须可以用以下任一方式回答: 
       * 简短的多项选择(2-5个不同的、互斥的选项), 或
       * 单词 / 短语答案(明确约束: "Answer in <=5 words").
    - 仅包含答案实质上影响架构、数据建模、任务分解、测试设计、UX 行为、运营准备或合规性验证的问题.
    - 确保类别覆盖平衡: 尝试首先覆盖最高影响的未解决类别; 避免在单个高影响领域(例如, 安全态势)未解决时询问两个低影响问题.
    - 排除已回答的问题、琐碎的风格偏好或规划级别的执行细节(除非阻碍正确性).
    - 偏好减少下游返工风险或防止不一致验收测试的澄清.
    - 如果超过 10 个候选问题, 通过(影响 * 不确定性)启发式选择前 10 个.

4. 分组提问流程(交互式): 
    - **以组为单位**提出问题, 每组最多包含 **5 个** 逻辑相关或无相互依赖的问题.
    - 确保组内问题已按依赖顺序排列 (先问前提条件, 再问后续细节).
    - 对于组内的每个多项选择题: 
       * **分析所有选项**并基于项目最佳实践、安全性、性能和可维护性确定**最合适的选项**.
       * 在问题上方突出显示你的**推荐选项**并附上清晰推理 (1-2 句话).
       * 格式为: 
         **Q[n]: <Question Text>**
         **Recommended:** Option [X] - <reasoning>
         | Option | Description |
         |--------|-------------|
         | A | ... |
         | B | ... |
       * 表格后添加: `You can reply with the option letter, accept the recommendation ("yes"), or provide a short answer.`
    - 对于组内的每个简答题: 
       * 提供你的**建议答案**及简要推理.
       * 格式为: 
         **Q[n]: <Question Text>**
         **Suggested:** <proposed answer> - <reasoning>
         Format: Short answer (<=5 words).
    - 用户回答后: 
       * 验证所有问题的回答. 允许用户一次性回答该组的所有问题 (例如: "1. A, 2. yes, 3. custom answer").
       * 如果某个回答模糊, 要求快速消除歧义 (不前进到下一组).
       * 一旦满意, 将其记录在工作内存中并移动到下一组问题 (如果有).
    - 在以下情况时停止进一步提问: 
       * 所有关键模糊性早期解决, 或用户发出完成信号 ("done", "proceed"), 或达到总计 10 个问题的上限.
    - 永远不要提前揭示未来组的问题.
    - 如果开始时没有有效问题, 立即报告没有关键模糊性.

5. 每次接受答案后的集成(增量更新方法): 
    - 维护规范的内存表示(开始时加载一次)加上原始文件内容.
    - 对于此会话中第一个集成的答案: 
       * 确保 `## Clarifications` 部分存在(如果缺失, 根据规范模板在最高级别的上下文 / 概述部分之后创建).
       * 在其下, 创建(如果不存在)今天的 `### Session YYYY-MM-DD` 子标题.
    - 接受后立即追加项目符号行: `- Q: <question> → A: <final answer>`.
    - 然后立即将澄清应用到最合适的部分: 
       * 功能模糊性 → 更新或在功能需求中添加项目符号.
       * 用户交互 / 角色区分 → 更新用户故事或角色子部分(如果存在), 包含澄清的角色、约束或场景.
       * 数据形状 / 实体 → 更新数据模型(添加字段、类型、关系)保持顺序; 简洁地记录添加的约束.
       * 非功能性约束 → 在非功能性 / 质量属性部分添加 / 修改可衡量标准(将模糊形容词转换为指标或明确目标).
       * 边缘情况 / 负面流程 → 在边缘情况 / 错误处理下添加新项目符号(或如果模板提供占位符则创建此类子部分).
       * 术语冲突 → 在整个规范中规范化术语; 仅在必要时通过添加一次 `(formerly referred to as "X")` 保留原始术语.
    - 如果澄清使早期模糊声明无效, 替换该声明而不是重复; 不留用过时的矛盾文本.
    - 每次集成后保存规范文件以最小化上下文丢失风险(原子覆盖).
    - 保持格式: 不重新排序不相关的部分; 保持标题层次结构完整.
    - 保持每个插入的澄清最小化和可测试(避免叙述性偏离).

6. 验证(每次写入后执行, 最终再进行一次完整检查): 
   - 澄清会话每个接受的答案只包含一个项目符号(无重复).
   - 总共询问(接受)的问题 ≤ 10.
   - 更新的部分不包含新答案旨在解决的持续模糊占位符.
   - 没有矛盾的早期声明保留(扫描已删除的现在无效的替代选择).
   - **多文档一致性检查**：确保新添加的澄清内容不与关联文档 (`IMPL_PLAN`, `TASKS`) 或用户提供的任何输入参考文档产生未解决的冲突，或已记录所需的同步更新需求。
   - Markdown 结构有效; 仅允许新标题: `## Clarifications`、`### Session YYYY-MM-DD`.
   - 术语一致性: 所有更新部分使用相同的规范术语.

7. 将更新的规范写回 `FEATURE_SPEC`.

8. 报告完成(提问循环结束或提前终止后): 
   - 询问和回答的问题数量.
   - 更新规范的路径.
   - 涉及的部分(列出名称).
   - 覆盖范围摘要表, 列出每个分类类别及状态: 已解决(曾是部分 / 缺失并已处理)、已推迟(超过问题配额或更适合规划)、清晰(已足够)、未完成(仍是部分 / 缺失但影响低).
   - 如果有任何未完成或已推迟的剩余, 建议是继续到 `/speckit.plan` 还是在规划后再次运行 `/speckit.clarify`.
   - 建议的下一个命令.

行为规则: 
- 如果没有发现有意义的模糊性(或所有潜在问题都是低影响的), 回应: "No critical ambiguities detected worth formal clarification." 并建议继续.
- 如果规范文件缺失, 指示用户首先运行 `/speckit.specify`(不要在此创建新规范).
- 永远不要超过总共 10 个询问的问题(单个问题的澄清重试不计为新问题).
- 避免推测性技术堆栈问题, 除非缺失阻碍功能清晰性.
- 尊重用户提前终止信号("stop"、"done"、"proceed").
 - 如果由于完全覆盖而没有提问, 输出紧凑的覆盖范围摘要(所有类别清晰)然后建议前进.
 - 如果达到配额但仍有未解决的高影响类别, 在已推迟下明确标记它们并附上理由.

优先级排序的上下文: {ARGS}
