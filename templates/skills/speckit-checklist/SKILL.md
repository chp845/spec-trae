
---
name: speckit-checklist
description: Generate custom checklists for current feature based on user requirements - quality, clarity, and completeness verification of requirements as "unit tests" for requirements writing.
license: MIT
compatibility: Requires speckit workflow.
metadata:
  author: speckit
  version: "1.0"
---

基于用户需求为当前功能生成自定义检查清单——验证质量、清晰度和完整性的需求"单元测试"。

## 清单目的："需求编写的单元测试"

**核心概念**：清单是**需求编写的单元测试**——它们验证特定领域中需求的质量、清晰度和完整性。

**不用于验证/测试：**
- ❌ 不是"验证按钮点击正确"
- ❌ 不是"测试错误处理有效"
- ❌ 不是"确认 API 返回 200"
- ❌ 不是检查代码/实现是否符合规范

**用于需求质量验证：**
- ✅ "是否为所有卡片类型定义了视觉层次需求？"（完整性）
- ✅ "'突出显示'是否通过具体尺寸/位置进行了量化？"（清晰度）
- ✅ "所有交互元素的悬停状态需求是否一致？"（一致性）
- ✅ "是否为键盘导航定义了可访问性需求？"（覆盖度）
- ✅ "规范是否定义了 logo 图像加载失败时的处理？"（边缘情况）

**比喻**：如果你的规范是用英文编写的代码，那么清单就是它的单元测试套件。你测试的是需求是否编写良好、完整、明确并准备好实施——而不是实现是否有效。

## 用户输入

```
$ARGUMENTS
```

在继续之前，你**必须**考虑用户输入（如果不为空）。

## 执行步骤

1. **设置**：从仓库根目录运行 `.specify/scripts/bash/create-new-feature.sh --json` 并解析 JSON 获取 FEATURE_DIR 和 AVAILABLE_DOCS。所有文件路径必须是绝对的。

2. **澄清意图（动态）**：推导最多三个初始上下文澄清问题（无预编目录）。它们必须：
   - 从用户的表述 + 从规范/计划/任务中提取的信号生成
   - 只询问实质上改变清单内容的信息
   - 如果在 `$已经明确，则单独ARGUMENTS` 中跳过

   **生成算法：**
   1. 提取信号：特征领域关键词、风险指标、利益相关者提示、明确的可交付成果
   2. 将信号聚类为候选焦点区域（最多 4 个），按相关性排序
   3. 识别可能的受众和时机
   4. 检测缺失的维度：范围广度、深度/严格程度、风险强调
   5. 从原型制定问题（范围精炼、风险优先级、深度校准、受众框架、边界排除、场景类差距）

   **交互不可能时的默认值：**
   - 深度：标准
   - 受众：代码相关则为审查者（PR）；否则为作者
   - 焦点：前 2 个相关性聚类

3. **理解用户请求**：结合 `$ARGUMENTS` + 澄清答案：
   - 推导清单主题（例如：安全、审查、部署、ux）
   - 整合用户明确提到的必需项目
   - 将焦点选择映射到类别框架

4. **加载功能上下文**：从 FEATURE_DIR 读取：
   - spec.md：功能需求和范围
   - plan.md（如果存在）：技术细节、依赖关系
   - tasks.md（如果存在）：实施任务

5. **生成清单**——创建"需求的单元测试"：
   - 创建 `FEATURE_DIR/checklists/` 目录（如果不存在）
   - 使用简短描述性名称生成唯一的清单文件名（例如 `ux.md`、`api.md`、`security.md`）
   - 从 CHK001 开始顺序编号
   - 每次 `/speckit.checklist` 运行创建**新**文件（绝不覆盖现有清单）

   **核心原则——测试需求，而非实现：**
   每个清单项目必须评估需求本身：
   - **完整性**：所有必要的需求是否已记录？
   - **清晰度**：需求是否明确无歧义且具体？
   - **一致性**：需求是否相互一致？
   - **可测量性**：需求是否可以客观验证？
   - **覆盖度**：是否涵盖了所有场景/边缘情况？

   **类别结构**——按质量维度分组项目：
   - 需求完整性
   - 需求清晰度
   - 需求一致性
   - 验收标准质量
   - 场景覆盖度
   - 边缘情况覆盖度
   - 非功能需求
   - 依赖关系和假设
   - 歧义和冲突

6. **结构参考**：遵循 `.specify/templates/checklist-template.md` 生成清单，包含 H1 标题、purpose/created 元数据、`##` 类别部分和 `- [ ] CHK###` 项目。

7. **报告**：输出创建的清单完整路径、项目数量，并提醒用户每次运行都会创建新文件。

## 重要说明

每次 `/speckit.checklist` 命令调用都会创建一个使用简短描述性名称的新清单文件。这允许：
- 创建多种不同类型的清单（例如 `ux.md`、`test.md`、`security.md`）
- 使用简单、易记的文件名来表明清单用途
- 在 `checklists/` 文件夹中轻松识别和导航

## 示例

**UX 需求质量**（`ux.md`）：
- "视觉层次需求是否通过可测量标准定义了？"（清晰度，Spec §FR-1）
- "UI 元素的数量和位置是否明确指定？"（完整性，Spec §FR-1）
- "悬停、焦点、活动等交互状态需求是否一致定义？"（一致性）

**API 需求质量**（`api.md`）：
- "是否为所有失败场景指定了错误响应格式？"（完整性）
- "速率限制要求是否通过具体阈值量化了？"（清晰度）
- "是否定义了外部依赖的重试/超时要求？"（覆盖度，缺口）

## 什么不要做

**❌ 错误**（测试实现）：
```markdown
- [ ] CHK001 - 验证着陆页显示 3 个剧集卡片 [Spec §FR-001]
- [ ] CHK002 - 测试桌面上的悬停状态是否正常工作 [Spec §FR-003]
```

**✅ 正确**（测试需求质量）：
```markdown
- [ ] CHK001 - 特色剧集的数量和布局是否明确指定？[完整性，Spec §FR-001]
- [ ] CHK002 - 所有交互元素的悬停状态需求是否一致定义？[一致性，Spec §FR-003]
```

**关键区别：**
- 错误：测试系统是否正常工作
- 正确：测试需求是否编写正确
